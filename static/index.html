<!DOCTYPE html>
<!--
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
-->
<html>
<head>

  <meta charset="utf-8">
  <meta name="description" content="WebRTC code samples">
  <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
  <meta itemprop="description" content="Client-side WebRTC code samples">
  <meta itemprop="image" content="../../../images/webrtc-icon-192x192.png">
  <meta itemprop="name" content="WebRTC code samples">
  <meta name="mobile-web-app-capable" content="yes">
  <meta id="theme-color" name="theme-color" content="#ffffff">

  <base target="_blank">

  <title>getUserMedia</title>
  <link href='https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Material+Icons' rel="stylesheet" type="text/css">
  <link href="https://unpkg.com/vuetify/dist/vuetify.min.css" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">


</head>

<body>
  <div id="app">
    <v-app>
      <v-content>
        <v-container :style="{'height':'100vh', 'min-height': 'min-content'}">
            <v-jumbotron color="grey lighten-2" height="min-content">
                <v-container fill-height>
                  <v-layout align-center text-xs-center>
                    <v-flex>
                      <h3 class="display-2">
                        <v-layout wrap v-if="$vuetify.breakpoint.xsOnly">
                          <v-flex xs12 sm6>
                              Putting a <v-icon large class="info--text">face</v-icon> 
                          </v-flex>
                          <v-flex xs12 sm6>
                              to a private <v-icon large class="info--text">vpn_key</v-icon>  
                          </v-flex>
                        </v-layout>
                        <div v-else>
                            Putting a 
                            <v-icon large class="info--text">face</v-icon> 
                            to a private <v-icon large class="info--text">vpn_key</v-icon>  
                        </div>
                      </h3>
                      <p class="title mt-2">Facial recognition and photo confirmation for DocuSign</p>
                      <p class="subheading mt-4">We all know DocuSign meets legal requirements – More than 300,000 businesses and organizations worldwide depend on just that. But some companies desire additional restrictions on exactly who can access documents and deeper insight into who <strong>really</strong> clicked sign.</p>
                      <v-divider class="mb-4 mt-4"></v-divider>
                      <v-layout wrap text-xs-center></v-layout>
                        <v-flex xs12 class="title mb-3 mt-3" v-if="showEnableCameraButton"> Your device supports a webcam – Check out our new features!</v-flex>
                        <v-flex xs12>
                          <v-btn 
                              v-show="showEnableCameraButton"
                              color="info"
                              @click.native.stop="enableCamera(); $vuetify.goTo('#demo')" 
                            >
                            Enable Camera Access
                          </v-btn>
                      </v-flex>
                      </v-layout>
                    </v-flex>
                  </v-layout>
                </v-container>
              </v-jumbotron>
          </v-container>
        </v-container>
        <v-container id="demo" :style="{'min-height': '500px'}">
          <v-layout align-center justify-center>
              <canvas v-show="showCanvas && showVideoFeed"></canvas>
          </v-layout>
          <v-layout wrap align-center justify-center>
            
              <v-btn 
                v-show="showEnableCameraButton"
                :color="showVideoFeed ? 'error' : 'info'"
                @click.native.stop="showVideoFeed ?  disableCamera() : enableCamera()"
                >
                  {{  showVideoFeed ? 'Disable Camera' : 'Enable Camera Access' }}
                </v-btn>
            
                <v-btn 
                v-show="showVideoFeed"
                color="info"
                @click.native.stop="takePhoto"
              >
                Take Photo
              </v-btn>
            
              <v-btn 
                v-show="photo && showVideoFeed"
                :color="showCanvas ? 'warning' : 'success'"
                @click.native.stop="showCanvas = !showCanvas"
              >
                {{  showCanvas ? 'Hide Photo' : 'Show Photo' }}
              </v-btn>
            <camera 
              v-show="showVideoFeed"
              ref="camera" 
              class="elevation-1"
            />

          </v-layout>
          
  
            <!-- <p class="warning"><strong>Warning:</strong> if you're not using headphones, pressing play will cause feedback.</p>
        
            <p>Display the video stream from <code>getUserMedia()</code> in a video element.</p>
        
            <p>The <code>MediaStream</code> object <code>stream</code> passed to the <code>getUserMedia()</code> callback is in global scope, so you can inspect it from the console.</p> -->
        </v-container>
      </v-content>
    </v-app>
  </div>

  <script src="https://unpkg.com/vue/dist/vue.js"></script>
  <script src="https://unpkg.com/vuetify/dist/vuetify.js"></script>
  <script type='text/javascript' src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <!-- <script type='text/javascript' src="./js/webRTC.js"></script> -->
  <script>
      const camera = Vue.component('camera', {
        template: `<video autoplay playsinline ref="innerCamera"/>`,
        data() {
          return {
            stream: null,
            constraints: {
              audio: false,
              video: {
                width: 640, // must be fixed at 640 to work on Safari (iPhone!)
                deviceId: null, // tbd
                facingMode: "user" // force front-facing camera
              }
            }
          }
        },
        methods: {
          connectToCamera(){
            return new Promise((resolve, reject) => {
              navigator.mediaDevices.getUserMedia(this.constraints)
              .then((stream) => {
                this.stream = stream;
                this.$el.srcObject = stream; 
                console.log('connected to camera');
                resolve(stream)
              })
              .catch((err) => {
                console.error(`${err.name}: ${err.message}`);
                reject(`${err.name}: ${err.message}`)
              });
            })
          }
        },
        mounted() {
          navigator.mediaDevices.enumerateDevices()
          .then((devices) => {
            devices = devices.filter(v => (v.kind === 'videoinput'));
            if(devices.length === 0) {
              const error = 'There are no supported video devices';
              console.error(error)
              alert(error)
              return;
            }

            // otherwise, at least 1 video device 
            console.log(`Found ${devices.length} video devices`);
            // alert(`Found ${devices.length} video devices`)

            // get front-facing cameras by default
            frontFacingCameras = devices.filter(v => (v.label.includes('front') || v.label.includes('user')));
            this.constraints.video.deviceId = frontFacingCameras.length === 1 ? frontFacingCameras[0].deviceId : devices[0].deviceId;
          })
          .catch((err) => {
            console.error(`${err.name}: ${err.message}`);
          });
        },
      })
      new Vue({ 
        el: '#app',
        components: {
          camera
        },
        data() {
          return {
            showEnableCameraButton: false,
            showVideoFeed: false,
            showCanvas: false,
            photo: null
          }
        },
        mounted() {
          this.$watch(() => {return this.$refs.camera.constraints.video.deviceId},
          (newId, oldId) => {
            console.log(`oldId: ${oldId}, newId: ${newId}`)
            if(newId){ // if camera
              this.showEnableCameraButton = true;
            }
          })
        },
        methods: {
          takePhoto() {
            var canvas = window.canvas = document.querySelector('canvas');
            canvas.width = this.$refs.camera.$refs.innerCamera.videoWidth;
            canvas.height = this.$refs.camera.$refs.innerCamera.videoHeight;
            canvas.getContext('2d').drawImage(this.$refs.camera.$refs.innerCamera, 0, 0, canvas.width, canvas.height);
            this.photo = canvas.toDataURL('image/png');
          },
          enableCamera() {
            this.$refs.camera.connectToCamera()
            .then(stream => {
              console.log(stream);
              this.showVideoFeed = true;
            })
            .catch(console.error);
          },
          disableCamera() {
            this.$refs.camera.stream.getTracks()[0].stop();
            this.showVideoFeed = false;
          }
        }
       })
  </script>
</body>
</html>